import {
    Parsed,
    RangeObject,
    StringifyOptions,
    StrictCIDR,
    ConditionPredicate
} from './IP-types';
/**
 * A utility class that provides static methods for validating and formatting IP and CIDR strings.
 * Unlike the {@link IP} class, these methods are stateless and ideal for one-off checks or
 * transformations on varying inputs.
 */
export class IPUtil extends IPBase {
    /**
     * Returns a sanitized representation of an IP string.
     *
     * Examples:
     * * `192.168.0.1` (IPv4; same as {@link IPUtil.abbreviate})
     * * `fd12:3456:789a:1:0:0:0:0`
     *
     * Inaccurate CIDRs are corrected automatically:
     * * Input: `fd12:3456:789a:1::1/64`
     * * Output: `fd12:3456:789a:1:0:0:0:0/64`
     *
     * @param {string} ipStr IP or CIDR string to sanitize.
     * @param {boolean} [capitalize=false] Whether to capitalize the output.
     * @param {ConditionPredicate} [conditionPredicate]
     * Optional condition for filtering valid IPs.
     * @returns {string?} Sanitized string, or `null` if:
     * * The input string does not represent an IP address.
     * * The parsed IP address does not meet the conditions specified by `conditionPredicate`
     */
    static sanitize(ipStr: string, capitalize?: boolean | undefined, conditionPredicate?: ConditionPredicate | undefined): string | null;
    /**
     * Returns an abbreviated representation of an IP string.
     *
     * Examples:
     * * `192.168.0.1` (IPv4; same as {@link IPUtil.sanitize})
     * * `fd12:3456:789a:1::`
     *
     * Inaccurate CIDRs are corrected automatically:
     * * Input: `fd12:3456:789a:1:0:0:0:1/64`
     * * Output: `fd12:3456:789a:1::/64`
     *
     * @param {string} ipStr IP or CIDR string to abbreviate.
     * @param {boolean} [capitalize=false] Whether to capitalize the output.
     * @param {ConditionPredicate} [conditionPredicate] Optional condition for filtering valid IPs.
     * @returns {string?} Abbreviated string, or `null` if:
     * * The input string does not represent an IP address.
     * * The parsed IP address does not meet the conditions specified by `conditionPredicate`
     */
    static abbreviate(ipStr: string, capitalize?: boolean | undefined, conditionPredicate?: ConditionPredicate | undefined): string | null;
    /**
     * Returns a fully expanded (lengthened) representation of an IP string.
     *
     * Examples:
     * * `192.168.000.001`
     * * `fd12:3456:789a:0001:0000:0000:0000:0000`
     *
     * Inaccurate CIDRs are corrected automatically:
     * * Input: `fd12:3456:789a:1:0:0:0:1/64`
     * * Output: `fd12:3456:789a:0001:0000:0000:0000:0000/64`
     *
     * @param {string} ipStr IP or CIDR string to expand.
     * @param {boolean} [capitalize=false] Whether to capitalize the output.
     * @param {ConditionPredicate} [conditionPredicate] Optional condition for filtering valid IPs.
     * @returns {string?} Expanded string, or `null` if:
     * * The input string does not represent an IP address.
     * * The parsed IP address does not meet the conditions specified by `conditionPredicate`
     */
    static lengthen(ipStr: string, capitalize?: boolean | undefined, conditionPredicate?: ConditionPredicate | undefined): string | null;
    /**
     * Validates whether a string is a valid IP or CIDR address.
     *
     * - If `allowCidr` is `true`, CIDR suffixes are allowed.
     * - If `allowCidr` is `'strict'`, the method returns a normalized CIDR string if the input is valid
     * but not in canonical form.
     * - If `allowCidr` is `false`, CIDR suffixes are disallowed.
     *
     * ### Return values:
     * * `true`: The input is valid.
     * * `false`: The input is invalid.
     * * `string`: A corrected CIDR string (only if `allowCidr === 'strict'` and normalization is needed).
     *
     * @param {string} ipStr The IP or CIDR string to validate.
     * @param {boolean | StrictCIDR} allowCidr Whether to allow CIDRs, or require strict CIDR format.
     * @param {ConditionPredicate} [conditionPredicate] Optional function to apply additional validation.
     * @param {StringifyOptions} [options] Output formatting options (used only if returning a string).
     * @returns {boolean | string} See above.
     * @protected
     */
    protected static validate(ipStr: string, allowCidr: boolean | StrictCIDR, conditionPredicate?: ConditionPredicate | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether the input is a valid IP or CIDR address.
     *
     * @param {string} ipStr The IP or CIDR string to check.
     * @param {boolean | StrictCIDR} [allowCidr=false] Whether to allow CIDRs, or require strict CIDR format.
     * @param {StringifyOptions} [options] Formatting options for corrected CIDRs.
     * @returns {boolean | string} Returns `true` if valid, `false` if invalid, or a normalized CIDR string.
     */
    static isIP(ipStr: string, allowCidr?: boolean | "strict" | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether the input is a valid IPv4 address or IPv4 CIDR.
     *
     * @param {string} ipStr The IPv4 or IPv4 CIDR string to check.
     * @param {boolean | StrictCIDR} [allowCidr=false] Whether to allow CIDRs, or require strict CIDR format.
     * @param {StringifyOptions} [options] Formatting options for corrected CIDRs.
     * @returns {boolean | string} Returns `true` if valid, `false` if invalid, or a normalized CIDR string.
     */
    static isIPv4(ipStr: string, allowCidr?: boolean | "strict" | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether the input is a valid IPv6 address or IPv6 CIDR.
     *
     * @param {string} ipStr The IPv6 or IPv6 CIDR string to check.
     * @param {boolean | StrictCIDR} [allowCidr=false] Whether to allow CIDRs, or require strict CIDR format.
     * @param {StringifyOptions} [options] Formatting options for corrected CIDRs.
     * @returns {boolean | string} Returns `true` if valid, `false` if invalid, or a normalized CIDR string.
     */
    static isIPv6(ipStr: string, allowCidr?: boolean | "strict" | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether the input is a valid CIDR (either IPv4 or IPv6).
     *
     * @param {string} ipStr The CIDR string to check.
     * @param {StrictCIDR} [mode] Require strict CIDR formatting if `'strict'` is passed.
     * @param {StringifyOptions} [options] Formatting options for corrected CIDRs.
     * @returns {boolean | string} Returns `true` if valid, `false` if invalid, or a normalized CIDR string.
     */
    static isCIDR(ipStr: string, mode?: "strict" | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether the input is a valid IPv4 CIDR.
     *
     * @param {string} ipStr The IPv4 CIDR string to check.
     * @param {StrictCIDR} [mode] Require strict CIDR formatting if `'strict'` is passed.
     * @param {StringifyOptions} [options] Formatting options for corrected CIDRs.
     * @returns {boolean | string} Returns `true` if valid, `false` if invalid, or a normalized CIDR string.
     */
    static isIPv4CIDR(ipStr: string, mode?: "strict" | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether the input is a valid IPv6 CIDR.
     *
     * @param {string} ipStr The IPv6 CIDR string to check.
     * @param {StrictCIDR} [mode] Require strict CIDR formatting if `'strict'` is passed.
     * @param {StringifyOptions} [options] Formatting options for corrected CIDRs.
     * @returns {boolean | string} Returns `true` if valid, `false` if invalid, or a normalized CIDR string.
     */
    static isIPv6CIDR(ipStr: string, mode?: "strict" | undefined, options?: StringifyOptions | undefined): boolean | string;
    /**
     * Checks whether a given IP address is within the CIDR range of another.
     *
     * @param {string | IP} ipStr The target IP address to evaluate.
     * @param {string | IP} cidrStr The CIDR string or IP instance representing the range.
     * @returns {boolean?} `true` if `ipStr` is within the range of `cidrStr`, `false` if not, or `null`
     * if either input is invalid.
     */
    static isInRange(ipStr: string | IP, cidrStr: string | IP): boolean | null;
    /**
     * Checks whether a given IP address is within any of the CIDR ranges in the array.
     *
     * @param {string | IP} ipStr The IP address to evaluate.
     * @param {(string | IP)[]} cidrArr An array of CIDR strings or IP instances to check against.
     * @returns {number?} The index of the first matching CIDR in the array, `-1` if none match, or `null`
     * if `ipStr` is invalid.
     */
    static isInAnyRange(ipStr: string | IP, cidrArr: (string | IP)[]): number | null;
    /**
     * Checks whether a given IP address is within all CIDR ranges in the array.
     *
     * @param {string | IP} ipStr The IP address to evaluate.
     * @param {(string | IP)[]} cidrArr An array of CIDR strings or IP instances to check against.
     * @returns {boolean?} `true` if the IP is within all CIDRs, `false` if not, or `null` if `ipStr` is invalid
     * or `cidrArr` is not an array or an empty array.
     */
    static isInAllRanges(ipStr: string | IP, cidrArr: (string | IP)[]): boolean | null;
    /**
     * Checks whether a CIDR range contains the specified IP address.
     *
     * @param {string | IP} cidrStr The CIDR string or IP instance representing the containing range.
     * @param {string | IP} ipStr The target IP address to check.
     * @returns {boolean?} `true` if `cidrStr` contains `ipStr`, `false` if not, or `null` if either input is invalid.
     */
    static contains(cidrStr: string | IP, ipStr: string | IP): boolean | null;
    /**
     * Checks whether a CIDR range contains any of the IP addresses in the array.
     *
     * @param {string | IP} cidrStr The CIDR string or IP instance representing the containing range.
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to test.
     * @returns {number?} The index of the first match in `ipArr`, `-1` if none match, or `null` if `cidrStr` is invalid.
     */
    static containsAny(cidrStr: string | IP, ipArr: (string | IP)[]): number | null;
    /**
     * Checks whether a CIDR range contains all of the IP addresses in the array.
     *
     * @param {string | IP} cidrStr The CIDR string or IP instance representing the containing range.
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to test.
     * @returns {boolean?} `true` if all IPs are contained, `false` if any are not, or `null` if `cidrStr` is invalid or
     * `ipArr` is not an array or an empty array.
     */
    static containsAll(cidrStr: string | IP, ipArr: (string | IP)[]): boolean | null;
    /**
     * Checks whether two IP addresses are equal.
     *
     * @param {string | IP} ipStr1 The first IP address to compare.
     * @param {string | IP} ipStr2 The second IP address to compare.
     * @returns {boolean?} `true` if the IPs are equal, `false` if not, or `null` if either input is invalid.
     */
    static equals(ipStr1: string | IP, ipStr2: string | IP): boolean | null;
    /**
     * Checks whether an IP address is equal to any address in a given array.
     *
     * @param {string | IP} ipStr The IP address to compare.
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to check against.
     * @returns {number?} The index of the first match in `ipArr`, `-1` if none match, or `null` if `ipStr` is invalid.
     */
    static equalsAny(ipStr: string | IP, ipArr: (string | IP)[]): number | null;
    /**
     * Checks whether an IP address is equal to all addresses in a given array.
     *
     * @param {string | IP} ipStr The IP address to compare.
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to compare against.
     * @returns {boolean?} `true` if all addresses are equal to `ipStr`, `false` otherwise, or `null` if `ipStr` is invalid
     * or `ipArr` is not an array or an empty array.
     */
    static equalsAll(ipStr: string | IP, ipArr: (string | IP)[]): boolean | null;
    /**
     * @throws {Error} Always throws. This class cannot be instantiated.
     * @hidden
     */
    constructor();
}
/**
 * The IP class. Unlike the static {@link IPUtil} class, this class provides several instance methods
 * that can be used to perform validations on the same IP or CIDR address multiple times.
 *
 * To initialize a new instance, use {@link IP.newFromText} or {@link IP.newFromRange}:
 * ```ts
 * const ip = IP.newFromText('fd12:3456:789a:1::1');
 * if (!ip) return;
 * console.log(ip.stringify()); // fd12:3456:789a:1:0:0:0:1
 * ```
 */
export class IP extends IPBase {
    /**
     * Initializes an IP instance from a string.
     *
     * @param {string} ipStr An IP- or CIDR-representing string.
     * @returns {IP?} A new `IP` instance if parsing succeeds, or `null` if the input is invalid.
     */
    static newFromText(ipStr: string): IP | null;
    /**
     * Initializes an IP instance from a string and a range (*aka.* a bit length).
     *
     * @param {string} ipStr An IP- or CIDR-representing string. If a CIDR string is passed, the `/XX` part
     * will be overridden by `range`.
     * @param {number} range The desired CIDR bit length (0–32 for IPv4, 0–128 for IPv6).
     * @returns {IP?} A new `IP` instance if parsing succeeds, or `null` if the input or range is invalid.
     * @throws {TypeError} If `range` is not a number.
     */
    static newFromRange(ipStr: string, range: number): IP | null;
    /**
     * Private constructor. Use {@link IP.newFromText} or {@link IP.newFromRange} to create a new instance.
     *
     * @param {RangeObject} range An object containing internal CIDR information.
     * @protected
     */
    protected constructor();
    /**
     * @type {number[]}
     * @readonly
     * @protected
     */
    protected readonly first: number[];
    /**
     * @type {number[]}
     * @readonly
     * @protected
     */
    protected readonly last: number[];
    /**
     * @type {number}
     * @readonly
     * @protected
     */
    protected readonly bitLen: number;
    /**
     * @type {boolean}
     * @readonly
     * @protected
     */
    protected readonly isCidr: boolean;
    /**
     * Gets a copy of the internal CIDR-related properties.
     *
     * @returns {RangeObject} An object containing `first`, `last`, `bitLen`, and `isCidr`.
     */
    getProperties(): RangeObject;
    /**
     * Returns the IP version as a number.
     *
     * @returns {4 | 6} The IP version: `4` for IPv4 or `6` for IPv6.
     */
    get version(): 4 | 6;
    /**
     * Gets the IP version as a string in the format `IPv4` or `IPv6`.
     *
     * @returns {string} A string representation of the IP version.
     */
    getVersion(): string;
    /**
     * Returns the stringified form of this IP or CIDR block.
     *
     * @param {StringifyOptions} [options] Optional formatting options.
     * If omitted, a default "sanitized" format will be used.
     * @returns {string} A properly formatted string representation of the IP or CIDR.
     *
     * Note: If the instance was initialized from an imprecise CIDR string,
     * the output will reflect the corrected internal format.
     * ```ts
     * const ip = IP.newFromText('fd12:3456:789a:1::1/64');
     * ip.stringify(); // fd12:3456:789a:1:0:0:0:0/64
     * ```
     */
    stringify(options?: StringifyOptions | undefined): string;
    /**
     * Returns the stringified form of this IP or CIDR block in an abbreviated format.
     *
     * This is a shorthand method of {@link stringify} with the {@link StringifyOptions.mode | mode}
     * option set to `'short'`.
     *
     * @param {boolean} [capitalize=false] Whether to capitalize the output.
     * @returns A properly formatted string representation of the IP or CIDR.
     */
    abbreviate(capitalize?: boolean | undefined): string;
    /**
     * Returns the stringified form of this IP or CIDR block in a sanitized format.
     *
     * This is a shorthand method of {@link stringify} with the {@link StringifyOptions.mode | mode}
     * option unset.
     *
     * @param {boolean} [capitalize=false] Whether to capitalize the output.
     * @returns A properly formatted string representation of the IP or CIDR.
     */
    sanitize(capitalize?: boolean | undefined): string;
    /**
     * Returns the stringified form of this IP or CIDR block in a lengthened format.
     *
     * This is a shorthand method of {@link stringify} with the {@link StringifyOptions.mode | mode}
     * option set to `'long'`.
     *
     * @param {boolean} [capitalize=false] Whether to capitalize the output.
     * @returns A properly formatted string representation of the IP or CIDR.
     */
    lengthen(capitalize?: boolean | undefined): string;
    /**
     * Checks whether the current instance represents an IPv4 address.
     *
     * @param {boolean} [allowCidr=false] Whether to allow a CIDR address.
     * @returns {boolean} A boolean indicating whether the current instance represents an IPv4 address.
     */
    isIPv4(allowCidr?: boolean | undefined): boolean;
    /**
     * Checks whether the current instance represents an IPv6 address.
     *
     * @param {boolean} [allowCidr=false] Whether to allow a CIDR address.
     * @returns {boolean} A boolean indicating whether the current instance represents an IPv6 address.
     */
    isIPv6(allowCidr?: boolean | undefined): boolean;
    /**
     * Checks whether the current instance represents a CIDR address.
     *
     * @returns {boolean} A boolean indicating whether the current instance represents a CIDR address.
     */
    isCIDR(): boolean;
    /**
     * Checks whether the current instance represents an IPv4 CIDR address.
     *
     * @returns {boolean} A boolean indicating whether the current instance represents an IPv4 CIDR address.
     */
    isIPv4CIDR(): boolean;
    /**
     * Checks whether the current instance represents an IPv6 CIDR address.
     *
     * @returns {boolean} A boolean indicating whether the current instance represents an IPv6 CIDR address.
     */
    isIPv6CIDR(): boolean;
    /**
     * Gets the bit length of the current instance.
     *
     * This always returns a number between `0-32` for IPv4 and `0-128` for IPv6.
     * To check whether the current instance represents a CIDR address, use {@link IP.isCIDR}.
     * @returns {number} The bit length as a number.
     */
    getBitLength(): number;
    /**
     * Gets range information of the IP instance.
     *
     * @overload
     * @param {false} [getInstance=false] Whether to get the start and end IP addresses as IP instances.
     * @param {StringifyOptions} [options] Optional formatting options for the `cidr`, `first`,
     * and `last` properties.
     * @returns {{bitLen: number; cidr: string; first: string; last: string;}}
     */
    getRange(getInstance?: false | undefined, options?: StringifyOptions | undefined): {
        bitLen: number;
        cidr: string;
        first: string;
        last: string;
    };
    /**
     * Gets range information of the IP instance.
     *
     * @overload
     * @param {true} getInstance Whether to get the start and end IP addresses as IP instances.
     * @param {StringifyOptions} [options] Optional formatting options for the `cidr` property.
     * @returns {{bitLen: number; cidr: string; first: IP; last: IP;}}
     */
    getRange(getInstance: true, options?: StringifyOptions | undefined): {
        bitLen: number;
        cidr: string;
        first: IP;
        last: IP;
    };
    /**
     * Checks whether the IP address associated with this instance is within the CIDR range of another.
     *
     * @param {string | IP} cidrStr The CIDR string or IP instance representing the range.
     * @returns {boolean?} A boolean indicating whether the IP address is within the CIDR range, or
     * `null` if `cidrStr` is invalid.
     */
    isInRange(cidrStr: string | IP): boolean | null;
    /**
     * Checks whether the IP address associated with this instance is within any of the CIDR ranges in the array.
     *
     * @param {(string | IP)[]} cidrArr An array of CIDR strings or IP instances to check against.
     * @returns {number} The index of the first matching CIDR in the array, or `-1` if none match.
     */
    isInAnyRange(cidrArr: (string | IP)[]): number;
    /**
     * Checks whether the IP address associated with this instance is within all CIDR ranges in the array.
     *
     * @param {(string | IP)[]} cidrArr An array of CIDR strings or IP instances to check against.
     * @returns {boolean?} `true` if the IP is within all CIDRs, `false` if not, or `null` if `cidrArr` is
     * not an array or an empty array.
     */
    isInAllRanges(cidrArr: (string | IP)[]): boolean | null;
    /**
     * Checks whether the CIDR range associated with this instance contains the specified IP address.
     *
     * @param {string | IP} ipStr The target IP address to check.
     * @returns {boolean?} `true` if the CIDR range contains `ipStr`, `false` if not, or `null` if `ipStr` is invalid.
     */
    contains(ipStr: string | IP): boolean | null;
    /**
     * Checks whether the CIDR range associated with this instance contains any of the IP addresses in the array.
     *
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to test.
     * @returns {number} The index of the first match in `ipArr`, or `-1` if none match.
     */
    containsAny(ipArr: (string | IP)[]): number;
    /**
     * Checks whether the CIDR range associated with this instance contains all of the IP addresses in the array.
     *
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to test.
     * @returns {boolean?} `true` if all IPs are contained, `false` if any are not, or `null` if
     * `ipArr` is not an array or an empty array.
     */
    containsAll(ipArr: (string | IP)[]): boolean | null;
    /**
     * Checks whether the IP address associated with this intance is equal to a given IP address.
     *
     * @param {string | IP} ipStr The IP address to compare.
     * @returns {boolean?} `true` if the IPs are equal, `false` if not, or `null` if `ipStr` is invalid.
     */
    equals(ipStr: string | IP): boolean | null;
    /**
     * Checks whether the IP address associated with this intance is equal to any address in a given array.
     *
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to check against.
     * @returns {number} The index of the first match in `ipArr`, or `-1` if none match.
     */
    equalsAny(ipArr: (string | IP)[]): number;
    /**
     * Checks whether the IP address associated with this intance is equal to all addresses in a given array.
     *
     * @param {(string | IP)[]} ipArr An array of IP or CIDR strings or IP instances to compare against.
     * @returns {boolean?} `true` if all addresses are equal to this IP instance, `false` otherwise, or
     * `null` if `ipArr` is not an array or an empty array.
     */
    equalsAll(ipArr: (string | IP)[]): boolean | null;
}
/**
 * ip-wiki — IP Address Utility Library
 * @version 1.1.2
 * @see https://dr4goniez.github.io/ip-wiki/index.html API documentation
 */
/**
 * Abstract class with protected methods for IP handling.
 * @abstract
 */
declare class IPBase {
    /**
     * Returns a trimmed string with all Unicode bidirectional characters removed.
     *
     * Unicode bidirectional characters are special invisible characters that can slip into
     * cut-and-pasted strings, which are shown as red dots in WikiEditor. They can cause issues
     * when parsing IP addresses.
     *
     * @see MediaWikiTitleCodec::splitTitleString in MediaWiki core
     *
     * @param {string} str
     * @returns {string}
     */
    static clean(str: string): string;
    /**
     * Parses a string potentially representing an IP or CIDR address.
     *
     * @param {string} ipStr The string to parse.
     * @param {number} [bitLen] Optional bit length for CIDR parsing.
     * @returns {Parsed?} A parsed object, or `null` if:
     * * `ipStr` is not a string.
     * * It does not represent a valid IP address.
     * * It contains an invalid CIDR bit length.
     * @protected
     */
    protected static parse(ipStr: string, bitLen?: number | undefined): Parsed | null;
    /**
     * Returns the first and last IPs in the given range.
     *
     * @param {number[]} parts Decimal parts of the IP address.
     * @param {number?} bitLen Optional CIDR bit length.
     * @returns {RangeObject}
     * @protected
     */
    protected static parseRange(parts: number[], bitLen: number | null): RangeObject;
    /**
     * Converts an array of decimal IP parts into a string.
     *
     * @param {number[]} decimals Array of decimal parts.
     * @param {string} suffix Suffix to append (e.g., `/24`).
     * @param {StringifyOptions} [options]
     * @returns {string}
     * @protected
     */
    protected static stringify(decimals: number[], suffix: string, options?: StringifyOptions | undefined): string;
    /**
     * Parses and stringifies an IP string with optional filtering.
     *
     * @param {string} ipStr IP or CIDR string to parse.
     * @param {StringifyOptions} options Options for formatting.
     * @param {ConditionPredicate} [conditionPredicate]
     * A predicate to filter addresses by version and CIDR.
     * @returns {string?} `null` if:
     * * The input string does not represent an IP address.
     * * The parsed IP address does not meet the conditions specified by `conditionPredicate`
     * @protected
     */
    protected static parseAndStringify(ipStr: string, options: StringifyOptions, conditionPredicate?: ConditionPredicate | undefined): string | null;
    /**
     * Compares two IP address ranges to check for inclusion.
     *
     * @param {RangeObject} ip1 Range object of the first IP.
     * @param {string | IP} ip2 IP string or IP instance to compare against.
     * @param {"<" | ">"} comparator Use `<` if `ip2` should contain `ip1`, or `>` if `ip1` should contain `ip2`.
     * @returns {boolean?} `null` if `ip2` is not a valid IP address.
     * @protected
     */
    protected static compareRanges(ip1: RangeObject, ip2: string | IP, comparator: "<" | ">"): boolean | null;
    /**
     * Parses an IP string or instance into a range object.
     *
     * @param {string | IP} ip An IP/CIDR string or IP instance.
     * @returns {RangeObject?} Range object, or `null` if the input is not a valid IP.
     * @protected
     */
    protected static getRangeObject(ip: string | IP): RangeObject | null;
    /**
     * Checks if two IP addresses are equal.
     *
     * @param {RangeObject} ipObj Range object of the first IP.
     * @param {string | IP} ipStr IP or CIDR string, or IP instance.
     * @returns {boolean?} `null` if the second input is invalid.
     * @protected
     */
    protected static checkEquality(ipObj: RangeObject, ipStr: string | IP): boolean | null;
    /**
     * Constructor for abstract class.
     * Throws an error if called directly.
     *
     * @param {boolean} override Must be `true` to instantiate.
     * @throws {Error} If `override` is not `true`.
     * @hidden
     */
    constructor(override: boolean);
}
export {};
