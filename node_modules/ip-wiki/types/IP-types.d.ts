/**
 * The return type of `IPBase.parse`.
 */
export interface Parsed {
    /**
     * The IP address parts as an array of decimal numbers.
     */
    parts: number[];
    /**
     * The bit length, if the parsed address is a CIDR.
     */
    bitLen: number | null;
}
/**
 * The structure of the internal private properties of an {@link IP} instance.
 * (A copy of these properties can be retrieved using {@link IP.getProperties}.)
 *
 * This object represents the parsing result of the original IP string, forcibly interpreted
 * as a CIDR address. "Forcible interpretation" refers to the internal conversion of any IP
 * address into CIDR form, e.g., `192.168.0.1` → `192.168.0.1/32`, stored as arrays of decimals
 * along with a bit length. The `isCidr` property indicates whether the original input really was
 * a CIDR.
 */
export interface RangeObject {
    /**
     * An array of decimal numbers representing the first IP in the CIDR range.
     */
    first: number[];
    /**
     * An array of decimal numbers representing the last IP in the CIDR range.
     */
    last: number[];
    /**
     * The bit length of the CIDR address.
     */
    bitLen: number;
    /**
     * `false` if the original address was not a CIDR.
     */
    isCidr: boolean;
}
/**
 * Options for formatting IP addresses in the output.
 */
export interface StringifyOptions {
    /**
     * `undefined`: Returns the IP address in its "sanitized" form. For example:
     * - `192.168.0.1` (for IPv4 addresses, same as `mode: 'short'`)
     * - `fd12:3456:789a:1:0:0:0:0`
     *
     * `'short'`: Returns the IP address in its shortest notation. For example:
     * - `192.168.0.1` (IPv4, same as `mode: undefined`)
     * - `fd12:3456:789a:1::`
     *
     * `'long'`: Returns the IP address in its longest notation, with each segment
     * padded with leading zeros. For example:
     * - `192.168.000.001`
     * - `fd12:3456:789a:0001:0000:0000:0000:0000`
     */
    mode?: "short" | "long";
    /**
     * Whether to capitalize the output IP address.
     */
    capitalize?: boolean;
}
/**
 * The strict CIDR validation mode ensures that CIDR addresses have a matching prefix
 * for the specified bit length. If a CIDR string is technically valid but the prefix
 * does not align with the given bit length, it will be corrected and returned as a string.
 *
 * For example, `192.168.0.1/24` is considered inaccurate because the prefix should be
 * `192.168.0.0` for a /24 subnet. In strict mode, this input is not rejected—instead,
 * it is interpreted as valid and automatically corrected.
 *
 * When strict mode is off, `IPUtil.isIP('192.168.0.1/24', true)` returns `true`.
 * When strict mode is on, the method returns the corrected CIDR string:
 *
 * ```ts
 * // allowCidr: false or undefined
 * console.log(IPUtil.isIP('192.168.0.1')); // true
 * console.log(IPUtil.isIP('192.168.0.1/24')); // false
 *
 * // allowCidr: true
 * console.log(IPUtil.isIP('192.168.0.1', true)); // true
 * console.log(IPUtil.isIP('192.168.0.1/24', true)); // true
 * console.log(IPUtil.isIP('192.168.0.0/24', true)); // true
 *
 * // allowCidr: 'strict'
 * console.log(IPUtil.isIP('192.168.0.1', 'strict')); // true (same as allowCidr: true)
 * console.log(IPUtil.isIP('192.168.0.1/24', 'strict')); // "192.168.0.0/24"
 * console.log(IPUtil.isIP('192.168.0.0/24', 'strict')); // true
 * ```
 */
export type StrictCIDR = "strict";
/**
 * The type of an optional callback function used to filter out IP addresses that do not meet
 * specific conditions.
 *
 * @param version The IP version: `4` or `6`. By default, both are accepted.
 * @param isCidr Indicates whether the address is a CIDR. By default, both CIDRs and non-CIDRs are accepted.
 * @returns Whether the IP address satisfies the specified condition(s).
 */
export type ConditionPredicate = (version: 4 | 6, isCidr: boolean) => boolean;
